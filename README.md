## java设计模式秘密
**什么是设计模式?**

设计模式(Design pattern)是一套被反复使用,多数人知晓,经过分类编目的,代码设计经验的总结
### 懒汉设计模式 与 饿汉式的区别
1. 饿汉模式的特点是加载类的时候比较慢,但运行时获取对象的速度比较快,线程安全
2. 懒汉模式的特点是加载类的时候比较快,但运行时获取对象的速度比较慢,线程不安全
### 观察者设计模式
### 代理模式
- **概念:** 为其他对象提供一种代理以控制对这个对象的访问
- **代理模式定义:** 为其他一种代理以控制d对这个对象的访问.代理对象起到中介作用,可以去掉功能服务或增加额外的服务
- **常见的代理模式:** 
  - 远程代理
  - 虚拟代理
  - 保护代理
  - 智能引用代理
- **两种实现方式:** 

一. 静态代理
 
  
```
代理和被代理对象在代理之前是确定的.他们都是实现相同的接口或者继承相同的类
```
![静态代理](docs/static-proxy.png)
   二. 动态代理  
  > java动态代理类位于java.lang.reflect包下,一般涉及到以下两个类:
  ![代理模式时序图](docs/UML-proxy.png)  
  
(I)Interface InvocationHandler: 该接口中仅定义了一个方法

```
public object invoke(Object obj,Method method,Object[] args)在实际使用时,
第一个参数obj一般指的是代理类,method是被代理的方法,args为该方法的参数数组这个抽象方法在代理类中动态实现
```  
(II)Proxy:该类即为动态代理类
```
static Object newProxyInstance(ClassLoader loader,Class[] interface,InvocationHandler h):
返回代理类的实例,返回后的代理类可以当作被代理类使用(可使用被代理类的在接口中声明过的方法)
```

#### 步骤
1. 创建一个实现接口 InvocationHandler 的类,它必须实现invoke方法
2. 创建被代理的类和接口
3. 调用proxy的静态方法,创建一个代理类
![报错代码](docs/error-proxy.png)  
```java
newProxyInstance(ClassLoader loader,Class[] interfaces,InvocationHandler h)
```
4. 通过代理调用方法
  
![动态代理](docs/dynamic-proxy.png)  

### 适配器模式
- 组合
> 采用组合方式的适配器成为对象适配器

特点: 把 "被适配器者" 作为一个对象组合到适配器类,以修改目标接口包装的被适配者

- 继承
> 采用继承方式的称为类适配器

特点: 通过多重继承不兼容接口, 实现对目标接口的匹配单一的为某个类而实现适配
![类适配器](docs/class-adapter.png)  

### 责任链模式
1. 什么是责任链模式
2. 如何实现责任链模式
3. 责任链模式如何解耦
4. 责任链模式的应用

### 工厂模式
* 概念
```
实例化对象,用工厂方法代替new操作
工厂模式包括工厂方法模式和抽象工厂模式
抽象工厂模式是工厂模式的扩展
```
* 意图
```
定义一个接口创建对象,但是让子类决定哪些类需要被实例化.工厂方法把实例化的工作推迟到子类中去实现
```
* 应用场景
```
1.有一组类似的对象需要创建
2.在编码时不能预见x需要创建哪种类的实例 
3.系统需要考虑扩展性,不应依赖于产品类实例如何被创建,组合和表达细节
```
* 设计思想
1. 尽量松耦合,一个对象的依赖对象的变化与本身无关
2. 具体产品与客户端剥离,责任分割
* 好处

### 模板方法
1. 什么是模板方法模式
2. 如何实现模板方法模式
3. 模板方法模式的特点